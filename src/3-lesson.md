# Занятие №3

**Тема**  
Рекурсивные алгоритмы. Переход между итерационным алгоритмом и рекурсивным. Динамическое программирование. Мемоизация.  
Задания ЕГЭ: 16, 23

Третье занятие посвящено задачам на рекурсию. Хотя и существуют способы решения этих заданий на бумаге или в `Excel`, программирование позволяет решать их более эффективно и универсально.

## Задание №16

В 16 задании вам предлагается вычислить одно или несколько значений функции, заданной рекурсивно.

### Теория

**Рекурсивная функция** - функция, которая вызывает саму себя. Алгоритм называется рекурсивным, если в его определении содержится вызов этого же алгоритма.  
**Глубина рекурсии** - количество вложенных вызовов функции.  
**Ветвистость рекурсии** - количество различных веток выполнения функции.  
**Базовый случай** - часть рекурсивной функции, в которой не происходит вызова самой себя.  
**Мемоизация** - сохранение результатов выполнения функции для последующего использования.  
**Динамическое программирование** - метод решения сложных задач путём разбиения их на более простые подзадачи и решения каждой подзадачи только один раз.  
**Итеративный алгоритм** - алгоритм, в котором циклы используются для повторения одного и того же блока кода.

Чтобы корректно задать рекурсивную функцию, необходимо определить:

1. Базовый случай. То есть условие окончания рекурсии, набор аргументов, при котором функция возвращает значение без вызова самой себя.
2. Шаг рекурсии. То есть рекурсивную/рекуррентную формулу, которая определяет значение функции через значение этой же функции с другими аргументами.

#### Пример

**Факториал**  
Факториал числа n - произведение всех натуральных чисел от 1 до n. Следует отметить, что определить факториал можно как рекурсивно, так и итеративно.  
Итеративное определение: $n!=\prod_{k=1}^{n}k$  
Рекурсивное определение: $n!=n\cdot(n-1)!$  
Не утруждаясь доказательством, можно сказать, что любой рекурсивный алгоритм можно переделать в итеративный. Это может быть полезно, если рекурсивный алгоритм работает слишком медленно или занимает слишком много памяти.  
Напишем реализацию обоих вариантов факториала на `Python`:

```python {title="Рекурсивный факториал"}
def Factorial(n):
    if n == 0:
        return 1
    return n * Factorial(n - 1)
```

```python {title="Итеративный факториал"}
def Factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

Справедливо заметить, что эту задачу можно решить как вручную на бумаге, так и в `Excel`, но эти способы неэффективны и не универсальны.
Подробнее про переход между итеративным и рекурсивным алгоритмом вы можете прочитать на [Хабре](https://habr.com/ru/articles/533034/) [@habrrecursion].  
Поскольку в условии вам будет даваться рекурсивный алгоритм, написать его будет проще, чем переделывать в итеративный. Однако у рекурсивных алгоритмов есть свои проблемы, о которых мы поговорим далее.

### Методика решения

Как и для большинства заданий ЕГЭ, думать либо не нужно вообще, либо делать это в последнюю очередь. Сначала следует просто написать наивную реализацию рекурсивного алгоритма из условия и запустить. Нередко этого будет достаточно. Если же программа зависнет или выдаст ошибку, то придётся немного подумать и использовать один из нижеописанных методов для разрешения проблемы.

### Варианты задания

- [Простейшая рекурсия](#простейшая-рекурсия)
- [Дополнительные условия](#дополнительные-условия)
- [Глубокая рекурсия](#глубокая-рекурсия)
- [Мемоизация](#мемоизация)
- [На отрезке](#на-отрезке)
- [Подбор аргументов](#подбор-аргументов)
- [Прочие варианты задания 16](#прочие-варианты-задания-16)

#### Простейшая рекурсия

Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n + 5, при n ≤ 42;  
F(n) = F(n–2)·n, при n > 42.  
Чему равно значение F(50)?  
_Ответ: 228307200_  
**Решение**  
Как и было сказано, думать не нужно. Просто пишем наивную реализацию алгоритма из условия, запускаем и получаем ответ.

```python
def F(n):
    if n <= 42:
        return n + 5
    return F(n - 2) * n


print(F(50))  # 228307200
```

Заметьте, что писать `else` после `return` не нужно, так как функция завершается после `return`.

#### Дополнительные условия

(5F7DD8) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1 при n < 3;  
F(n) = F(n − 1) + n − 1, если n > 2 и при этом n чётно;  
F(n) = F(n − 2) + 2 × n − 2, если n > 2 и при этом n нечётно.  
Чему равно значение функции F(33)?  
_Ответ: 545_  
**Решение**  
Единственное отличие от предыдущего задания - дополнительные условия. На ход решения это никак не влияет.

```python
def F(n):
    if n < 3:
        return 1
    if n % 2 == 0:
        return F(n - 1) + n - 1
    return F(n - 2) + 2 * n - 2


print(F(33))  # 545
```

#### Глубокая рекурсия

(C0EC82) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1 при n = 1;  
F(n) = n – 2 + F(n − 1), если n > 1.  
Чему равно значение выражения F(2024) – F(2022)?  
_Ответ: 4043_  
**Решение**

Уяснив истину о том, что думать нужно в последнюю очередь, пишем наивную реализацию алгоритма из условия и...

```python
def F(n):
    if n == 1:
        return 1
    return n - 2 + F(n - 1)


print(F(2024) - F(2022))
```

...получаем ошибку `RecursionError: maximum recursion depth exceeded`.

```shell
return n - 2 + F(n - 1)
               ^^^^^^^^
[Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```

Это произошло из-за того, что глубина рекурсии превысила максимально допустимую. Есть несколько способов решения этой проблемы.

_Способ 1 - изменить максимальную глубину_  
У многих языков программирования есть ограничение на глубину рекурсии. По тексту ошибки можно понять, что в `Python` максимальная глубина рекурсии ограничена приблизительно 1000 вызовами. Это искусственное ограничение, которое можно изменить с помощью функции `sys.setrecursionlimit`. Если глубина рекурсии слишком велика, это может привести к переполнению стека и аварийному завершению программы, но в ЕГЭ вы вряд ли столкнётесь с этой проблемой.

```python
import sys

sys.setrecursionlimit(10**6)


def F(n):
    if n == 1:
        return 1
    return n - 2 + F(n - 1)


print(F(2024) - F(2022))  # 4043
```

Не забываем импортировать модуль `sys` и вызвать функцию `sys.setrecursionlimit` до вызова рекурсивной функции. В качестве аргумента передаём какое-нибудь большое число, например, $10^6$.

_Способ 2 - переделать рекурсивный алгоритм в итеративный_

```python
def F(n):
    result = 1
    for i in range(2, n + 1):
        result = i - 2 + result
    return result


print(F(2024) - F(2022))  # 4043
```

Этот способ работает всегда, но требует больше усилий и времени. В данном случае переделать рекурсивный алгоритм в итеративный несложно, но это не всегда так.

_Способ 2.5 - динамическое программирование_

```python
results = {}
results[1] = 1

for n in range(2, 2024 + 1):
    results[n] = n - 2 + results[n - 1]

print(results[2024] - results[2022])  # 4043
```

Этот способ является частным случаем динамического программирования, когда мы сохраняем результаты выполнения функции для последующего использования. В данном случае это не сильно ускорило программу, но в некоторых ситуациях это может быть полезно.

_Способ 3 - аналитический_

Можно заметить, что значение F(n) это некоторая сумма включающая в себя все слагаемые суммы F(n - 1). Это значит, что при вычитании F(2022) из F(2024) почти всё сократится, а останется только маленький промежуток между 2022 и 2024, который легко посчитать вручную: $2024 - 2 + 2023 - 2 = 4043$.  
В незапамятные времена, когда ЕГЭ по информатике писали на бумаге, этот способ был единственным. Сейчас же я рекомендую использовать его только в крайних случаях, когда другие методы не помогают, или в качестве проверки.

#### Мемоизация

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n при n ≤ 42;  
F(n) = F(n − 42) + F(n - 21), если n > 42.  
Чему равно значение выражения F(2024) - F(2007)?  
_Ответ: 463346400277720193459_  
**Решение**  
Сначала пишем наивную реализацию алгоритма из условия и запускаем.

```python
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))
```

Ошибки нет, ведь глубина рекурсии невелика, но программа работает очень медленно. Сейчас на каждом шаге рекурсии она разделяется на две ветви, и каждая из этих ветвей разделяется на две ветви, и так далее. В итоге получается огромное количество вычислений.
До этого момента мы сталкивались с глубокой рекурсией, но не с ветвистой. В общем случае нет тривиального способа оптимизировать ветвистую рекурсию, но в ситуациях, когда одни и те же значения функции вычисляются многократно, можно использовать мемоизацию.
В данном случае, можно заметить, что действительно, F(n) будет вызвана от одних и тех же аргументов многократно. Это значит, что можно сохранять результаты выполнения функции для последующего использования.

```python
memo = {}


def F(n):
    if n in memo:
        return memo[n]

    if n <= 42:
        memo[n] = n
        return n

    memo[n] = F(n - 42) + F(n - 21)
    return memo[n]


print(F(2024) - F(2007))  # 463346400277720193459
```

Создаём словарь `memo`, в котором будем хранить результаты выполнения функции. Если результат для аргумента `n` уже вычислен, возвращаем его из словаря. Если нет, вычисляем и сохраняем в словаре.
Теперь программа работает быстро, и мы получаем правильный ответ.
Средства языка `Python` позволяют нам и вовсе не писать мемоизацию вручную, а использовать декоратор `functools.lru_cache`[^4].

```python
from functools import lru_cache


@lru_cache()
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))  # 463346400277720193459
```

Внутри декоратора `lru_cache` есть словарь, в котором хранятся результаты выполнения функции. Если не передавать в декоратор аргументов, он будет хранить 128 последних уникальных результатов. В нашем случае этого достаточно, но если нужно хранить больше результатов, можно передать аргумент `maxsize` с нужным значением. `@lru_cache(maxsize=10**6)` или `@lru_cache(maxsize=None)` для хранения всех результатов.
В `Python 3.9` добавили декоратор `functools.cache`, который работает так же, как и `@lru_cache(maxsize=None)`, но чуть быстрее.

```python
from functools import cache


@cache
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))  # 463346400277720193459
```

Предугадать какая версия `Python` будет установлена на компьютере, на котором вы будете писать ЕГЭ, невозможно, поэтому я рекомендую использовать `lru_cache`.

[^4]: Строго говоря, несмотря на то, что кэширование является частным случаем мемоизации, то, что мы делали в этом примере кэшированием не является и использование слова "cache" в названии декораторов не совсем корректно. Впрочем, в жизни эти два термина часто используются взаимозаменяемо.

#### На отрезке

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = $n^3$ + 71, при n > 42;  
F(n) = 3 \* F(n + 1) + F(n + 2), при чётных n ≤ 42;  
F(n) = F(n + 3) + 2 \* F(n + 4), при нечётных n ≤ 42.  
Определите количество натуральных значений n из отрезка [1; 1000], для которых значение F(n) содержит цифру 7 ровно 2 раза.  
_Ответ: 173_  
**Решение**  
Это простая задача, не требующая рассуждений. Просто в ней требуется несколько иной формат ответа.

```python
def F(n):
    if n > 42:
        return n**3 + 71
    if n % 2 == 0:
        return 3 * F(n + 1) + F(n + 2)
    return F(n + 3) + 2 * F(n + 4)


counter = 0
for n in range(1, 1000 + 1):
    res = F(n)
    if str(res).count("7") == 2:
        counter += 1
print(counter)  # 173
```

Не забываем, что в `Python` можно преобразовывать число в строку с помощью функции `str` и посчитать количество вхождений подстроки с помощью метода `count`.

#### Подбор аргументов

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = $n^3$ + 71, при n > 42;  
F(n) = 3 \* F(n + 1) + F(n + 2), при чётных n ≤ 42;  
F(n) = F(n + 3) + 2 \* F(n + 4), при нечётных n ≤ 42.  
Определите значение n, для которого функция F(n) = 76332940559.  
_Ответ: 4242_  
**Решение**  
Задача аналогична предыдущей, но перебор здесь будет не по заранее заданному отрезку, а до тех пор, пока не будет найдено нужное значение.

```python
def F(n):
    if n > 42:
        return n**3 + 71
    if n % 2 == 0:
        return 3 * F(n + 1) + F(n + 2)
    return F(n + 3) + 2 * F(n + 4)


n = 1
while True:
    res = F(n)
    if res == 76332940559:
        print(n)  # 4242
        break
    n += 1
```

#### Прочие варианты задания 16

В старом формате ЕГЭ были задачи, в которых предоставлялся исходный код программы на нескольких языках программирования, и нужно было определить, что выведет программа. Сейчас, когда ЕГЭ пишется на компьютере, такие задачи стали неактуальными, но лучше знать о их существовании. Конечно же, такого рода задачи решаются прямым копированием и запуском кода программы на компьютере.

## Задание №23

В 23 задании вам предоставляется набор операций и предлагается определить количество программ, составленных из этих операций и удовлетворяющих некоторым условиям.

### Теория

Для решения этого задания мы будем пользоваться рекурсивным алгоритмом и базовыми правилами комбинаторики.  
**Правило умножения** - если элемент A можно выбрать n способами, и при любом выборе A элемент B можно выбрать m способами, то пару (A, B) можно выбрать n$\cdot$m способами.  
**Правило сложения** - если элемент A можно выбрать n способами, а элемент B можно выбрать m способами, причём любой выбор элемента A отличен от любого выбора элемента B, то выбрать A или B можно n + m способами.

### Методика решения

Это задание можно решить на бумаге, нарисовав дерево всех возможных программ, но часто это неэффективно. Так же, как и в задании №16 существует эзотерический способ решения в `Excel`, о котором я не буду говорить.
Вместо этого, можно написать рекурсивный алгоритм, перебирающий все возможные программы. Для этого существует простой шаблон, который будет описан далее.
Можно решить задачу несколько иначе, например сохраняя все возможные программы в список и поочерёдно их исполняя, но нижеописанный метод более универсален и прост.

### Варианты задания

#### Примитив 23

(E28170) Исполнитель Минус преобразует число на экране.
У исполнителя есть две команды, которым присвоены номера:

1. Вычесть 2
2. Вычесть 5

Первая команда уменьшает число на экране на 2, вторая уменьшает это число на 5. Программа для исполнителя Минус – это последовательность команд.  
Сколько существует программ, которые число 23 преобразуют в число 2?  
_Ответ: 29_  
**Решение**  
Как и было сказано для решения этой задачи, можно написать рекурсивный алгоритм, перебирающий все возможные программы.

```python
def f(start, end):
    if start < end:
        return 0
    if start == end:
        return 1
    return f(start - 2, end) + f(start - 5, end)


print(f(23, 2))  # 29
```

Функция `f` принимает два аргумента: `start` - число, из которого мы начинаем, и `end` - число, в которое мы хотим прийти. Сама функция возвращает количество программ, которые преобразуют `start` в `end`. Дерево вызовов этой рекурсивной функции будет выглядеть примерно так:

![Я не буду рисовать всё дерево целиком, но вы можете сделать это сами в качестве упражнения.](src/images/3-lesson/image1.jpg){ width=80% }

Обе доступные команды уменьшают число, а значит, если `start` меньше `end`, то количество программ, преобразующих `start` в `end`, равно 0. Если `start` равно `end`, то количество программ равно 1 (пустая программа). В противном случае количество программ равно сумме количеств программ, преобразующих `start - 2` в `end` и `start - 5` в `end`. Почему здесь именно сумма следует из правила сложения комбинаторики. Если можно из `start - 2` преобразовать в `end` `n` способами, а из `start - 5` в `end` `m` способами, то из `start` в `end` можно преобразовать `n + m` способами. Интуитивное понимание этого можно обрести, внимательно посмотрев на дерево вызовов функции.

#### Обязательный узел

(C0C817) Исполнитель преобразует число на экране.
У исполнителя есть две команды, которым присвоены номера:

1. Вычти 1
2. Найди целую часть от деления на 2

Первая из них уменьшает число на экране на 1, вторая заменяет число на экране на целую часть от деления числа на 2.
Программа для исполнителя – это последовательность команд.
Сколько существует программ, для которых при исходном числе 30 результатом является число 1, и при этом траектория вычислений содержит число 13?  
Траектория вычислений программы – это последовательность результатов выполнения всех команд программы. Например, для программы 122 при исходном числе 10 траектория состоит из чисел 9, 4, 2.  
_Ответ: 342_  
**Решение**  
Эта задача отличается от предыдущей тем, что траектория вычислений программы должна проходить через обязательный узел 13.
Рекурсивная функция `f` для это задачи будет выглядеть так же, а вот её вызов будет отличаться.

```python
def f(start, end):
    if start < end:
        return 0
    if start == end:
        return 1
    return f(start - 1, end) + f(start // 2, end)


print(f(30, 13) * f(13, 1))  # 342
```

Мы просто перемножаем количество программ, преобразующих 30 в 13, и количество программ, преобразующих 13 в 1. Это следует из правила умножения комбинаторики. Если можно из `start` преобразовать в `end` `n` способами, и из `end` в `finish` `m` способами, то из `start` в `finish` можно преобразовать `n * m` способами. Интуитивное понимание этого можно обрести, посмотрев на эту картинку:

![Из 30 в 13 ведут 4 пути, а из 13 в 1 - 3 пути $\Rightarrow$ всего $4\times3=12$ способов добраться из 30 в 1, проходя через 13](src/images/3-lesson/image2.jpg){ width=50% }

#### Избегаемый узел

(63A59E) Исполнитель преобразует число на экране.
У исполнителя есть три команды, которые обозначены латинскими буквами:  
A. Прибавить 1  
B. Умножить на 2  
C. Умножить на 3  
Программа для исполнителя – это последовательность команд.
Сколько существует программ, для которых при исходном числе 1 результатом является число 25, при этом траектория вычислений содержит число 11 и не содержит 15?  
Траектория вычислений программы – это последовательность результатов выполнения всех команд программы. Например, для программы CBA при исходном числе 7 траектория будет состоять из чисел 21, 42, 43.  
_Ответ: 46_  
**Решение**  
В этой задаче помимо обязательного узла 11, есть ещё и избегаемый узел 15. Что вообще возвращает наша функция? - количество программ, преобразующих `start` в `end`. В условии сказано, что в узле 15 программа оказаться не должна, а это значит, что количество программ, преобразующих `start` в `end` при `start = 15` равно 0 $\Rightarrow$ в рекурсивной функции `f` нужно добавить условие, которое будет возвращать 0, если `start` равно 15.

```python
def f(start, end):
    if start > end:
        return 0
    if start == 15:
        return 0
    if start == end:
        return 1
    return f(start + 1, end) + f(start * 2, end) + f(start * 3, end)


print(f(1, 11) * f(11, 25))  # 46
```

Так же тут важно не упустить тот факт, что теперь все команды увеличивают число, а не уменьшают его, как в предыдущих задачах. Это значит, что если `start` больше `end`, то количество программ, преобразующих `start` в `end`, равно 0.

#### Множество избегаемых узлов

Исполнитель преобразует число на экране.
У исполнителя есть две команды, которым присвоены номера:

1. Прибавь 2
2. Прибавь 5

Первая команда увеличивает число на экране на 2, вторая увеличивает это число на 5. Программа для исполнителя – это последовательность команд.
Сколько существует программ, которые число 1 преобразуют в число 42, при этом траектория вычислений содержит чисел, в которых есть цифра 7?  
_Ответ: 335_  
**Решение**  
Эта задача отличается от предыдущих только тем, что теперь избегаемый узел может быть не один и условие проверки на его наличие нужно будет изменить согласно условию задачи.

```python
def f(start, end):
    if start > end:
        return 0
    if str(start).count("7"):
        return 0
    if start == end:
        return 1
    return f(start + 2, end) + f(start + 5, end)


print(f(1, 42))  # 335
```

#### Сочетание обязательных узлов

Исполнитель преобразует число на экране.
У исполнителя есть две команды, которым присвоены номера:

1. Умножь на 3
2. Прибавь 5
3. Прибавь 7

Первая команда увеличивает число на экране в 3 раза, вторая увеличивает это число на 5, третья увеличивает это число на 7. Программа для исполнителя – это последовательность команд.
Сколько существует программ, которые число 1 преобразуют в число 73, при этом траектория вычислений содержит либо число 13, либо число 42, но не оба эти числа одновременно?  
_Ответ: 923_  
**Решение**  
Эта задача состоит из нескольких более простых подзадач.  
Количество программ, преобразующих 1 в 73, траектория вычислений которых содержит или только 13, или только 42 =  
= количество программ, преобразующих 1 в 73, траектория вычислений которых содержит 13 +  
\+ количество программ, преобразующих 1 в 73, траектория вычислений которых содержит 42 -  
\- удвоенное количество программ, преобразующих 1 в 73, траектория вычислений которых содержит и 13, и 42.  
Программы, траектория вычислений которых, проходит через оба числа нужно вычитать дважды потому, что они будут учтены и в первом, и во втором слагаемом.

```python
def f(start, end):
    if start > end:
        return 0
    if start == end:
        return 1
    return f(start * 3, end) + f(start + 5, end) + f(start + 7, end)


has_13 = f(1, 13) * f(13, 73)
has_42 = f(1, 42) * f(42, 73)
has_13_and_42 = f(1, 13) * f(13, 42) * f(42, 73)

print(has_13 + has_42 - 2 * has_13_and_42)  # 923
```

Наблюдаем, что рекурсивная функция `f` осталась той же, и только вызовы изменились.

#### Прочие варианты задания 23

Так же встречаются задачи, в которых нужно найти:

- количество программ, преобразующих A в Б, с чётным/нечётным количеством команд;
- количество программ, преобразующих A в Б, с суммой/произведением цифр/чисел в траектории вычислений равной какому-то числу;

Все эти задачи решаются аналогично. Нужно создать некоторый счетчик, отслеживающий выполнение дополнительного условия и передавать его в рекурсивную функцию. Все остальное остаётся неизменным.
