# Занятие №3

**Тема**  
Задания ЕГЭ: 7, 11

## Задание №16

Разделить понятия глубины рекурсии и ветвистости рекурсии.

### Варианты задания

#### Простейшая рекурсия

(№ 6208) (Д. Статный) Обозначим частное от деления натурального числа a на натуральное число b как a // b, а остаток как a % b. Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1, при n ≤ 400,  
F(n) = F(n–1)·(n – 400), если n > 400.  
Чему равно значение F(701)/F(697)?  
_Ответ: 8045910600_  
**Решение**  
В лоб пишем

```python
def F(n):
    if n <= 400:
        return 1
    return F(n - 1) * (n - 400)

print(F(701) / F(697))  # 8045910600.0
```

Только не забудь `.0` с конца убрать

#### Дополнительные условия

(№ 2267) (К. Амеличев) Алгоритм вычисления функции F(n) задан следующими соотношениями:  
F(n) = n при n ≤ 10;  
F(n) = n // 4 + F(n–10) при 10 < n ≤ 36;  
F(n) = 2·F(n–5) при n > 36  
Здесь // обозначает деление нацело. Чему равно значение величины F(100)?  
_Ответ: 180224_  
**Решение**  
Пишем в лоб

```python
def F(n):
    if n <= 10:
        return n
    if n <= 36:
        return n // 4 + F(n - 10)
    return 2 * F(n - 5)

print(F(100))  # 180224
```

Иногда дополнительные условия про четность, делимость на что-то или принадлежность некоторому диапазону: на решение это не влияет.

#### На отрезке

(№ 2279) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n\*n\*n + n, при n > 20  
F(n) = 3\*F(n+1) + F(n+3), при чётных n ≤ 20  
F(n) = F(n+2) + 2\*F(n+3), при нечётных n ≤ 20  
Определите количество натуральных значений n из отрезка [1; 1000], для которых значение F(n) не содержит цифру 1.  
_Ответ: 384_  
**Решение**  
В лоб

```python
def F(n):
    if n > 20:
        return n**3 + n
    if n % 2 == 0:
        return 3 * F(n + 1) + F(n + 3)
    else:
        return F(n + 2) + 2 * F(n + 3)


counter = 0
for n in range(1, 1000 + 1):
    res = F(n)
    if '1' not in str(res):
        counter += 1
print(counter)
```

Разные способы проверки на вхождение 1

```python
if '1' not in str(res)
if not '1' in str(res)
if not str(res).count('1')
if str(res).count('1') == 0
```

#### sdfsfsd

(№ 6523) (А. Богданов) Обозначим частное от деления натурального числа a на натуральное число b как a // b, а остаток как a%b. Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n, если n < 2;  
F(n) = n % 2 + 10· F(n//2), если n ≥ 2.  
Определите значение n, для которого функция F(n) = 100000100001000100101.  
_Ответ: 1065509_  
**Решение**

#### Глубокая рекурсия

(№ 6241) (PRO100 ЕГЭ) Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1, при n = 1,  
F(n) = n + F(n - 1), если n > 1.  
Чему равно значение выражения F(2023) - F(2019)?  
_Ответ: 8086_  
**Решение**  
В лоб пишем

```python
def F(n):
    if n == 1:
        return 1
    return n + F(n - 1)

print(F(2023) - F(2019))
```

и радостно получаем по лбу

```shell
return n + F(n - 1)
           ^^^^^^^^
[Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```

Способ 1 - изменить максимальную глубину

```python
import sys

def F(n):
    if n == 1:
        return 1
    return n + F(n - 1)

sys.setrecursionlimit(10**6)

print(F(2023) - F(2019))  # 8086
```

Способ 2 - переделать рекурсивный алгоритм в итеративный

```python
results = [None] * 2100
results[1] = 1

for n in range(2, 2100):
    results[n] = n + results[n - 1]

print(results[2023] - results[2019])  # 8086
```

Способ 3 - аналитический

F(n) - сумма всех чисел от 1 до n => F(2023) - F(2019) = 2020 + 2021 + 2022 + 2023 = 8086
