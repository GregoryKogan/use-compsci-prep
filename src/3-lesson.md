# Занятие №3

**Тема**  
Рекурсивные алгоритмы. Переход между итерационным алгоритмом и рекурсивным. Динамическое программирование. Мемоизация.  
Задания ЕГЭ: 16, 23

Третье занятие посвящено задачам на рекурсию. Хотя и существуют способы решения этих заданий на бумаге или в `Excel`, программирование позволяет решать их более эффективно и универсально.

## Задание №16

В 16 задании вам предлагается вычислить одно или несколько значений функции, заданной рекурсивно.

### Теория

**Рекурсивная функция** - функция, которая вызывает саму себя. Алгоритм называется рекурсивным, если в его определении содержится вызов этого же алгоритма.  
**Глубина рекурсии** - количество вложенных вызовов функции.  
**Ветвистость рекурсии** - количество различных веток выполнения функции.  
**Базовый случай** - часть рекурсивной функции, в которой не происходит вызова самой себя.  
**Мемоизация** - сохранение результатов выполнения функции для последующего использования.  
**Динамическое программирование** - метод решения сложных задач путём разбиения их на более простые подзадачи и решения каждой подзадачи только один раз.  
**Итеративный алгоритм** - алгоритм, в котором циклы используются для повторения одного и того же блока кода.

Чтобы корректно задать рекурсивную функцию, необходимо определить:

1. Базовый случай. То есть условие окончания рекурсии, набор аргументов, при котором функция возвращает значение без вызова самой себя.
2. Шаг рекурсии. То есть рекурсивную/рекуррентную формулу, которая определяет значение функции через значение этой же функции с другими аргументами.

#### Пример

**Факториал**  
Факториал числа n - произведение всех натуральных чисел от 1 до n. Следует отметить, что определить факториал можно как рекурсивно, так и итеративно.  
Итеративное определение: $n!=\prod_{k=1}^{n}k$  
Рекурсивное определение: $n!=n\cdot(n-1)!$  
Не утруждаясь доказательством, можно сказать, что любой рекурсивный алгоритм можно переделать в итеративный. Это может быть полезно, если рекурсивный алгоритм работает слишком медленно или занимает слишком много памяти.  
Напишем реализацию обоих вариантов факториала на `Python`:

```python {title="Рекурсивный факториал"}
def Factorial(n):
    if n == 0:
        return 1
    return n * Factorial(n - 1)
```

```python {title="Итеративный факториал"}
def Factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

Справедливо заметить, что эту задачу можно решить как вручную на бумаге, так и в `Excel`, но эти способы неэффективны и не универсальны.
Подробнее про переход между итеративным и рекурсивным алгоритмом вы можете прочитать на [Хабре](https://habr.com/ru/articles/533034/) [@habrrecursion].  
Поскольку в условии вам будет даваться рекурсивный алгоритм, написать его будет проще, чем переделывать в итеративный. Однако у рекурсивных алгоритмов есть свои проблемы, о которых мы поговорим далее.

### Методика решения

Как и для большинства заданий ЕГЭ, думать либо не нужно вообще, либо делать это в последнюю очередь. Сначала следует просто написать наивную реализацию рекурсивного алгоритма из условия и запустить. Нередко этого будет достаточно. Если же программа зависнет или выдаст ошибку, то придётся немного подумать и использовать один из нижеописанных методов для разрешения проблемы.

### Варианты задания

#### Простейшая рекурсия

Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n + 5, при n ≤ 42;  
F(n) = F(n–2)·n, при n > 42.  
Чему равно значение F(50)?  
_Ответ: 228307200_  
**Решение**  
Как и было сказано, думать не нужно. Просто пишем наивную реализацию алгоритмы из условия, запускаем и получаем ответ.

```python
def F(n):
    if n <= 42:
        return n + 5
    return F(n - 2) * n


print(F(50))  # 228307200
```

Заметьте, что писать `else` после `return` не нужно, так как функция завершается после `return`.

#### Дополнительные условия

(5F7DD8) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1 при n < 3;  
F(n) = F(n − 1) + n − 1, если n > 2 и при этом n чётно;  
F(n) = F(n − 2) + 2 × n − 2, если n > 2 и при этом n нечётно.  
Чему равно значение функции F(33)?  
_Ответ: 545_  
**Решение**  
Единственное отличие от предыдущего задания - дополнительные условия. На ход решения это никак не влияет.

```python
def F(n):
    if n < 3:
        return 1
    if n % 2 == 0:
        return F(n - 1) + n - 1
    return F(n - 2) + 2 * n - 2


print(F(33))  # 545
```

#### Глубокая рекурсия

(C0EC82) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = 1 при n = 1;  
F(n) = n – 2 + F(n − 1), если n > 1.  
Чему равно значение выражения F(2024) – F(2022)?  
_Ответ: 4043_  
**Решение**

Уяснив истину о том, что думать нужно в последнюю очередь, пишем наивную реализацию алгоритма из условия и...

```python
def F(n):
    if n == 1:
        return 1
    return n - 2 + F(n - 1)


print(F(2024) - F(2022))
```

...получаем ошибку `RecursionError: maximum recursion depth exceeded`.

```shell
return n - 2 + F(n - 1)
               ^^^^^^^^
[Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```

Это произошло из-за того, что глубина рекурсии превысила максимально допустимую. Есть несколько способов решения этой проблемы.

_Способ 1 - изменить максимальную глубину_  
У многих языков программирования есть ограничение на глубину рекурсии. По тексту ошибки можно понять, что в `Python` максимальная глубина рекурсии ограничена приблизительно 1000 вызовами. Это искусственное ограничение, которое можно изменить с помощью функции `sys.setrecursionlimit`. Если глубина рекурсии слишком велика, это может привести к переполнению стека и аварийному завершению программы, но в ЕГЭ вы вряд ли столкнётесь с этой проблемой.

```python
import sys

sys.setrecursionlimit(10**6)


def F(n):
    if n == 1:
        return 1
    return n - 2 + F(n - 1)


print(F(2024) - F(2022))  # 4043
```

Не забываем импортировать модуль `sys` и вызвать функцию `sys.setrecursionlimit` до вызова рекурсивной функции. В качестве аргумента передаём какое-нибудь большое число, например, $10^6$.

_Способ 2 - переделать рекурсивный алгоритм в итеративный_

```python
def F(n):
    result = 1
    for i in range(2, n + 1):
        result = i - 2 + result
    return result


print(F(2024) - F(2022))  # 4043
```

Этот способ работает всегда, но требует больше усилий и времени. В данном случае переделать рекурсивный алгоритм в итеративный несложно, но это не всегда так.

_Способ 2.5 - динамическое программирование_

```python
results = {}
results[1] = 1

for n in range(2, 2024 + 1):
    results[n] = n - 2 + results[n - 1]

print(results[2024] - results[2022])  # 4043
```

Этот способ является частным случаем динамического программирования, когда мы сохраняем результаты выполнения функции для последующего использования. В данном случае это не сильно ускорило программу, но в некоторых ситуациях это может быть полезно.

_Способ 3 - аналитический_

Можно заметить, что значение F(n) это некоторая сумма включающая в себя все слагаемые суммы F(n - 1). Это значит, что при вычитании F(2022) из F(2024) почти все слагаемые сократятся, останется только маленький промежуток между 2022 и 2024, который легко посчитать вручную: $2024 - 2 + 2023 - 2 = 4043$.  
В незапамятные времена, когда ЕГЭ по информатике писали на бумаге, этот способ был единственным. Сейчас же я рекомендую использовать его только в крайних случаях, когда другие методы не помогают, или в качестве проверки.

#### Мемоизация

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = n при n ≤ 42;  
F(n) = F(n − 42) + F(n - 21), если n > 42.  
Чему равно значение выражения F(2024) - F(2007)?  
_Ответ: 463346400277720193459_  
**Решение**  
Сначала пишем наивную реализацию алгоритма из условия и запускаем.

```python
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))
```

Ошибки нет, ведь глубина рекурсии невелика, но программа работает очень медленно. Сейчас на каждом шаге рекурсии она разделяется на две ветви, и каждая из этих ветвей разделяется на две ветви, и так далее. В итоге получается огромное количество вычислений.
До этого момента мы сталкивались с глубокой рекурсией, но не с ветвистой. В общем случае нет тривиального способа оптимизировать ветвистую рекурсию, но в ситуациях, когда одни и те же значения функции вычисляются многократно, можно использовать мемоизацию.
В данном случае, можно заметить, что действительно, F(n) будет вызвана от одних и тех же аргументов многократно. Это значит, что можно сохранять результаты выполнения функции для последующего использования.

```python
memo = {}


def F(n):
    if n in memo:
        return memo[n]

    if n <= 42:
        memo[n] = n
        return n

    memo[n] = F(n - 42) + F(n - 21)
    return memo[n]


print(F(2024) - F(2007))  # 463346400277720193459
```

Создаём словарь `memo`, в котором будем хранить результаты выполнения функции. Если результат для аргумента `n` уже вычислен, возвращаем его из словаря. Если нет, вычисляем и сохраняем в словаре.
Теперь программа работает быстро, и мы получаем правильный ответ.
Средства языка `Python` позволяют нам и вовсе не писать мемоизацию вручную, а использовать декоратор `functools.lru_cache`[^4].

```python
from functools import lru_cache


@lru_cache()
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))  # 463346400277720193459
```

Внутри декоратора `lru_cache` есть словарь, в котором хранятся результаты выполнения функции. Если не передавать в декоратор аргументов, он будет хранить 128 последних уникальных результатов. В нашем случае этого достаточно, но если нужно хранить больше результатов, можно передать аргумент `maxsize` с нужным значением. `@lru_cache(maxsize=10**6)` или `@lru_cache(maxsize=None)` для хранения всех результатов.
В `Python 3.9` добавили декоратор `functools.cache`, который работает так же, как и `@lru_cache(maxsize=None)`, но работает чуть быстрее.

```python
from functools import cache


@cache
def F(n):
    if n <= 42:
        return n
    return F(n - 42) + F(n - 21)


print(F(2024) - F(2007))  # 463346400277720193459
```

Предугадать какая версия `Python` будет установлена на компьютере, на котором вы будете писать ЕГЭ, невозможно, поэтому я рекомендую использовать `lru_cache`.

[^4]: Строго говоря, несмотря на то, что кэширование является частным случаем мемоизации, то, что мы делали в этом примере кэшированием не является и использование слова "cache" в названии декораторов не совсем корректно. Впрочем, в жизни эти два термина часто используются взаимозаменяемо.

#### На отрезке

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = $n^3$ + 71, при n > 42;  
F(n) = 3 \* F(n + 1) + F(n + 2), при чётных n ≤ 42;  
F(n) = F(n + 3) + 2 \* F(n + 4), при нечётных n ≤ 42.  
Определите количество натуральных значений n из отрезка [1; 1000], для которых значение F(n) содержит цифру 7 ровно 2 раза.  
_Ответ: 173_  
**Решение**  
Это простая задача, не требующая рассуждений. Просто в ней требуется несколько иной формат ответа.

```python
def F(n):
    if n > 42:
        return n**3 + 71
    if n % 2 == 0:
        return 3 * F(n + 1) + F(n + 2)
    return F(n + 3) + 2 * F(n + 4)


counter = 0
for n in range(1, 1000 + 1):
    res = F(n)
    if str(res).count("7") == 2:
        counter += 1
print(counter)  # 173
```

Не забываем, что в `Python` можно преобразовывать число в строку с помощью функции `str` и посчитать количество вхождений подстроки с помощью метода `count`.

#### Подбор аргументов

Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:  
F(n) = $n^3$ + 71, при n > 42;  
F(n) = 3 \* F(n + 1) + F(n + 2), при чётных n ≤ 42;  
F(n) = F(n + 3) + 2 \* F(n + 4), при нечётных n ≤ 42.  
Определите значение n, для которого функция F(n) = 76332940559.  
_Ответ: 4242_  
**Решение**  
Задача аналогична предыдущей, но перебор здесь будет не по заранее заданному отрезку, а до тех пор, пока не будет найдено нужное значение.

```python
def F(n):
    if n > 42:
        return n**3 + 71
    if n % 2 == 0:
        return 3 * F(n + 1) + F(n + 2)
    return F(n + 3) + 2 * F(n + 4)


n = 1
while True:
    res = F(n)
    if res == 76332940559:
        print(n)  # 4242
        break
    n += 1
```

#### Прочие варианты задания 16

В старом формате ЕГЭ были задачи, в которых предоставлялся исходный код программы на нескольких языках программирования, и нужно было определить, что выведет программа. Сейчас, когда ЕГЭ пишется на компьютере, такие задачи стали неактуальными, но лучше знать о их существовании. Конечно же, такого рода задачи решаются прямым копированием и запуском кода программы на компьютере.
